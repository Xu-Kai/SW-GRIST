.. _how_worked:

工作原理
########

SWGOMP如何编译源码
------------------

由于神威平台没有LTO支持，SWGOMP编译源码的方式分别编译主从代码。其具体流程为：是先使用对应语言的编译器编译主核程序，SWGOMP插件将在编译的过程中检查是否有Offload的代码段，如果有Offload代码段则会生成一个标记，编译器包装脚本检查这个标记后将决定停止编译还是去编译从核代码。

不需要的代码将在GCC的调用图构造完成后进行删除，所以你的代码至少要在使用主核和从核编译器时 **都能通过** 语法检查阶段。

除了存在Offload代码这一条件外，还有两种触发从核编译的方式，其中一种是我们常见的 ``#ifdef __sw_slave__`` ，编译包装脚本会搜索这个宏，如果发现这个宏也会触发从核编译。

但是SWGOMP并没有特别智能，你仍然需要 ``omp declare target`` 为你的从核函数声明需要从核化。

SWGOMP的线程库
--------------

与Athread的兼容性
~~~~~~~~~~~~~~~~~

SWGOMP并没有直接使用或者取代Athread线程库，而是在Athread库的基础上运行了从核常驻的任务服务器。
该任务服务器的一个特色是可以被主核唤醒也可以被从核唤醒。

考虑到用户使用Athread代码的需求，我对Athread库进行了链接时包装，运行Offload代码时将会初始化Athread和CRTS，如果调用 ``athread_spawn`` 和 ``athread_join`` 也是没有问题的，他们将会被重定向到任务服务器启动函数。
但有一个限制是 ``cgsp 64`` 目前是必需的，并且 ``athread_spawn`` 和 ``athread_join`` 也能且只能使用64个线程。

线程启动方式
~~~~~~~~~~~~

在没有打开OpenMP嵌套并行时，线程库的启动顺序为::

  主核 --IO写--> 0号从核 --RMA广播--> 第一列从核 --RMA广播 --> 其他从核

这里注意，不声明 ``num_teams`` 其实与 ``num_teams(1)`` 的逻辑是相同的，放心使用。

使用OpenMP嵌套并行时，则会进入一种比较复杂的树形启动方式，相对来说验证的少一些。如果有朋友用到了，可以提供测试用例给我。